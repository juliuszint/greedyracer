#line 1 "\\\\?\\C:\\Users\\Peter\\Documents\\Hochschule_Kempten\\Softwarepraktikum\\greedyracer\\source\\greedyracer\\Shaders\\Source\\postprocessing.hlsl"


#line 1 "postconstants.h"

SamplerState linearSampler : register ( s1 ) ; 
SamplerState pointSampler : register ( s2 ) ; 

cbuffer ObjectInfo : register ( b0 ) 
{ 
    matrix World ; 
} 

cbuffer TexInfo : register ( b7 ) 
{ 
    float4 f4ColorEffect : packoffset ( c0 ) ; 
    float fBlurStrength : packoffset ( c1 . x ) ; 
    uint uBlur : packoffset ( c1 . y ) ; 
    uint uEnhancedEdges : packoffset ( c1 . z ) ; 
    uint uMeanFilter : packoffset ( c1 . w ) ; 
    float fBloomOriginalIntensity : packoffset ( c2 . x ) ; 
    float fBloomIntensity : packoffset ( c2 . y ) ; 
    float fBloomOriginalSaturation : packoffset ( c2 . z ) ; 
    float fBloomSaturation : packoffset ( c2 . w ) ; 
    float fRayExposure : packoffset ( c3 . x ) ; 
    float fRayDecay : packoffset ( c3 . y ) ; 
    float fRayDensity : packoffset ( c3 . z ) ; 
    float fRayWeight : packoffset ( c3 . w ) ; 
    float fTimeDelta : packoffset ( c4 . x ) ; 
    float fBloomBlurDistance : packoffset ( c4 . y ) ; 
    float fDoFFar : packoffset ( c4 . z ) ; 
    float fDoFNear : packoffset ( c4 . w ) ; 
    float2 f2RayLightPos : packoffset ( c5 . x ) ; 
    float2 f2rcpFrame : packoffset ( c5 . z ) ; 
    float4 f4rcpFrameOpt : packoffset ( c6 ) ; 
    float4 f4DoFParams : packoffset ( c7 ) ; 
} 

#line 37
float CalcLuminance ( float3 f3Color ) 
{ 
    return max ( dot ( f3Color , float3 ( 0.299f , 0.587f , 0.114f ) ) , 0.0001f ) ; 
} 

float GetAvgLuminance ( Texture2D lumTex , float2 f2TexCoord ) 
{ 
    return exp ( lumTex . SampleLevel ( linearSampler , f2TexCoord , 10 ) . x ) ; 
} 

#line 48
float3 ToneMapFilmicALU ( float3 f3Color ) 
{ 
    f3Color = max ( 0.f , f3Color - 0.004f ) ; 
    f3Color = ( f3Color * ( 6.2f * f3Color + .5f ) ) / ( f3Color * ( 6.2f * f3Color + 1.7f ) + 0.06f ) ; 
    
#line 54
    return pow ( f3Color , 2.2f ) ; 
} 

#line 58
float3 ToneMapReinhard ( float3 f3Color , float fSaturation ) 
{ 
    float fPixelLuminance = CalcLuminance ( f3Color ) ; 
    float fToneMappedLuminance = fPixelLuminance / ( fPixelLuminance + 1.f ) ; 
    return fToneMappedLuminance * pow ( f3Color / fPixelLuminance , fSaturation ) ; 
} 

float3 CalcExposedColor ( float3 f3Color , float fAvgLuminance , float fThreshold , out float fExposure ) 
{ 
    fAvgLuminance = max ( fAvgLuminance , 0.0001f ) ; 
    float fKeyVal = 1.f ; 
    float fLinearExposure = ( fKeyVal / fAvgLuminance ) ; 
    fExposure = log2 ( max ( fLinearExposure , 0.0001f ) ) ; 
    fExposure -= fThreshold ; 
    
    return exp2 ( fExposure ) * f3Color ; 
} 

float3 ToneMap ( float3 f3Color , float fAvgLuminance , float fThreshold , float fSaturation , out float fExposure ) 
{ 
    float fPixelLuminance = CalcLuminance ( f3Color ) ; 
    fExposure = 0.f ; 
    f3Color = CalcExposedColor ( f3Color , fAvgLuminance , fThreshold , fExposure ) ; 
    f3Color = ToneMapFilmicALU ( f3Color ) ; 
    
    return f3Color ; 
} 

#line 2 "\\\\?\\C:\\Users\\Peter\\Documents\\Hochschule_Kempten\\Softwarepraktikum\\greedyracer\\source\\greedyracer\\Shaders\\Source\\postprocessing.hlsl"


#line 1 "fxaa.h"








#line 10




#line 20




#line 27



















#line 48




#line 61





#line 72



#line 85




#line 96


#line 99


#line 102








#line 113




#line 118


#line 121


#line 124





#line 137





#line 148





#line 160





#line 173











struct FxaaTex { SamplerState smpl ; Texture2D tex ; } ; 





#line 195


float4 FxaaPixelShader ( 

float2 pos , 

float4 posPos , 

#line 204
FxaaTex tex , 

#line 208
float2 rcpFrame , 

float4 rcpFrameOpt 
) { 
    
    
    float4 luma4A = tex . tex . GatherAlpha ( tex . smpl , pos . xy , int2 ( - 1 , - 1 ) ) ; 
    
    float4 rgbyM = tex . tex . SampleLevel ( tex . smpl , pos . xy , 0.0 ) ; 
    
    float4 luma4B = tex . tex . GatherAlpha ( tex . smpl , pos . xy ) ; 
    float lumaNE = tex . tex . SampleLevel ( tex . smpl , pos . xy , 0.0 , int2 ( 1 , - 1 ) ) . w ; 
    float lumaSW = tex . tex . SampleLevel ( tex . smpl , pos . xy , 0.0 , int2 ( - 1 , 1 ) ) . w ; 
    float lumaNW = luma4A . w ; 
    float lumaN = luma4A . z ; 
    float lumaW = luma4A . x ; 
    float lumaM = luma4A . y ; 
    float lumaE = luma4B . z ; 
    float lumaS = luma4B . x ; 
    float lumaSE = luma4B . y ; 
    
#line 235
    
    
    float rangeMin = min ( lumaM , min ( min ( lumaN , lumaW ) , min ( lumaS , lumaE ) ) ) ; 
    float rangeMax = max ( lumaM , max ( max ( lumaN , lumaW ) , max ( lumaS , lumaE ) ) ) ; 
    float range = rangeMax - rangeMin ; 
    
    if ( range < max ( ( 1.0 / 24.0 ) , rangeMax * ( 1.0 / 6.0 ) ) ) 
    
#line 244
    
    return rgbyM ; 
    
    
#line 253
    
    
    
    
    float lumaL = ( lumaN + lumaW + lumaE + lumaS ) * 0.25 ; 
    float rangeL = abs ( lumaL - lumaM ) ; 
    float blendL = saturate ( ( rangeL / range ) - ( 1.0 / 8.0 ) ) * ( 1.0 / ( 1.0 - ( 1.0 / 8.0 ) ) ) ; 
    blendL = min ( ( 3.0 / 4.0 ) , blendL ) ; 
    
    float edgeVert = 
    abs ( lumaNW + ( - 2.0 * lumaN ) + lumaNE ) + 
    2.0 * abs ( lumaW + ( - 2.0 * lumaM ) + lumaE ) + 
    abs ( lumaSW + ( - 2.0 * lumaS ) + lumaSE ) ; 
    float edgeHorz = 
    abs ( lumaNW + ( - 2.0 * lumaW ) + lumaSW ) + 
    2.0 * abs ( lumaN + ( - 2.0 * lumaM ) + lumaS ) + 
    abs ( lumaNE + ( - 2.0 * lumaE ) + lumaSE ) ; 
    bool horzSpan = edgeHorz >= edgeVert ; 
    
    float lengthSign = horzSpan ? - rcpFrame . y : - rcpFrame . x ; 
    if ( ! horzSpan ) lumaN = lumaW ; 
    if ( ! horzSpan ) lumaS = lumaE ; 
    float gradientN = abs ( lumaN - lumaM ) ; 
    float gradientS = abs ( lumaS - lumaM ) ; 
    lumaN = ( lumaN + lumaM ) * 0.5 ; 
    lumaS = ( lumaS + lumaM ) * 0.5 ; 
    
    bool pairN = gradientN >= gradientS ; 
    if ( ! pairN ) lumaN = lumaS ; 
    if ( ! pairN ) gradientN = gradientS ; 
    if ( ! pairN ) lengthSign *= - 1.0 ; 
    float2 posN ; 
    posN . x = pos . x + ( horzSpan ? 0.0 : lengthSign * 0.5 ) ; 
    posN . y = pos . y + ( horzSpan ? lengthSign * 0.5 : 0.0 ) ; 
    
    
    
    
    gradientN *= ( 1.0 / 4.0 ) ; 
    
    float2 posP = posN ; 
    float2 offNP = horzSpan ? 
    float2 ( rcpFrame . x , 0.0 ) : 
    float2 ( 0.0f , rcpFrame . y ) ; 
    float lumaEndN ; 
    float lumaEndP ; 
    bool doneN = false ; 
    bool doneP = false ; 
    posN += offNP * ( - 1.5 ) ; 
    posP += offNP * ( 1.5 ) ; 
    for ( int i = 0 ; i < 6 ; i ++ ) { 
        lumaEndN = tex . tex . SampleLevel ( tex . smpl , posN . xy , 0.0 ) . w ; 
        lumaEndP = tex . tex . SampleLevel ( tex . smpl , posP . xy , 0.0 ) . w ; 
        bool doneN2 = abs ( lumaEndN - lumaN ) >= gradientN ; 
        bool doneP2 = abs ( lumaEndP - lumaN ) >= gradientN ; 
        if ( doneN2 && ! doneN ) posN += offNP ; 
        if ( doneP2 && ! doneP ) posP -= offNP ; 
        if ( doneN2 && doneP2 ) break ; 
        doneN = doneN2 ; 
        doneP = doneP2 ; 
        if ( ! doneN ) posN -= offNP * 2.0 ; 
        if ( ! doneP ) posP += offNP * 2.0 ; 
    } 
    
    float dstN = horzSpan ? pos . x - posN . x : pos . y - posN . y ; 
    float dstP = horzSpan ? posP . x - pos . x : posP . y - pos . y ; 
    
    bool directionN = dstN < dstP ; 
    lumaEndN = directionN ? lumaEndN : lumaEndP ; 
    
    if ( ( ( lumaM - lumaN ) < 0.0 ) == ( ( lumaEndN - lumaN ) < 0.0 ) ) 
    lengthSign = 0.0 ; 
    
    float spanLength = ( dstP + dstN ) ; 
    dstN = directionN ? dstN : dstP ; 
    float subPixelOffset = 0.5 + ( dstN * ( - 1.0 / spanLength ) ) ; 
    subPixelOffset += blendL * ( 1.0 / 8.0 ) ; 
    subPixelOffset *= lengthSign ; 
    float3 rgbF = 
#line 333
    tex . tex . SampleLevel ( tex . smpl , float2 ( pos . x + ( horzSpan ? 0.0 : subPixelOffset ) , pos . y + ( horzSpan ? subPixelOffset : 0.0 ) ) , 0.0 ) . xyz ; 
    
    
    lumaL *= lumaL ; 
    
    float lumaF = dot ( rgbF , float3 ( 0.299 , 0.587 , 0.114 ) ) + ( 1.0 / ( 65536.0 * 256.0 ) ) ; 
    float lumaB = lerp ( lumaF , lumaL , blendL ) ; 
    float scale = min ( 4.0 , lumaB / lumaF ) ; 
    rgbF *= scale ; 
    return float4 ( rgbF , lumaM ) ; 
} 



#line 345


#line 13 "\\\\?\\C:\\Users\\Peter\\Documents\\Hochschule_Kempten\\Softwarepraktikum\\greedyracer\\source\\greedyracer\\Shaders\\Source\\postprocessing.hlsl"
Texture2D tex2D [ 8 ] : register ( t15 ) ; 

#line 17
struct VS_INPUT_POST 
{ 
    float4 f4Pos : POSITION ; 
    float3 f3Normal : NORMAL ; 
    float2 f2TexCoord : TEXCOORD ; 
    float3 f3Tangent : TANGENT ; 
    float3 f3Bitangent : BITANGENT ; 
} ; 

#line 27
struct PS_INPUT_POST 
{ 
    float4 f4Pos : SV_POSITION0 ; 
    float2 f2TexCoord : TEXCOORD0 ; 
    float4 f4VertexPos : TEXCOORD2 ; 
} ; 

#line 37
PS_INPUT_POST VS_POST ( VS_INPUT_POST input ) 
{ 
    PS_INPUT_POST output = ( PS_INPUT_POST ) 0 ; 
    output . f2TexCoord = input . f2TexCoord ; 
    
    output . f4Pos = mul ( input . f4Pos , World ) ; 
    
    return output ; 
} 

#line 53
float4 MeanFilter ( float2 f2TexCoord ) 
{ 
    float fWidth , fHeight ; 
    tex2D [ 7 ] . GetDimensions ( fWidth , fHeight ) ; 
    float fOffsetX = 1.f / fWidth ; 
    float fOffsetY = 1.f / fHeight ; 
    float4 f4ColorOut = float4 ( 0.f , 0.f , 0.f , 1.f ) ; 
    float2 fTex1 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y ) ; 
    float2 fTex2 = float2 ( f2TexCoord . x , f2TexCoord . y + fOffsetY ) ; 
    float2 fTex3 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y ) ; 
    float2 fTex4 = float2 ( f2TexCoord . x , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex5 = float2 ( f2TexCoord . x , f2TexCoord . y ) ; 
    float2 fTex6 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex7 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex8 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y + fOffsetY ) ; 
    float2 fTex9 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y + fOffsetY ) ; 
    
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex1 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex2 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex3 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex4 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex5 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex6 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex7 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex8 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex9 ) ; 
    return ( f4ColorOut *= 0.11111f ) ; 
} 

#line 86
float4 BinomialFilter ( float2 f2TexCoord , float fRadius ) 
{ 
    float fWidth , fHeight ; 
    tex2D [ 7 ] . GetDimensions ( fWidth , fHeight ) ; 
    float fOffsetX = 1.f / fWidth ; 
    float fOffsetY = 1.f / fHeight ; 
    fOffsetX *= fRadius ; 
    fOffsetY *= fRadius ; 
    float4 f4ColorOut = float4 ( 0.f , 0.f , 0.f , 1.f ) ; 
    float2 fTex1 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y ) ; 
    float2 fTex2 = float2 ( f2TexCoord . x , f2TexCoord . y + fOffsetY ) ; 
    float2 fTex3 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y ) ; 
    float2 fTex4 = float2 ( f2TexCoord . x , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex5 = float2 ( f2TexCoord . x , f2TexCoord . y ) ; 
    float2 fTex6 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex7 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex8 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y + fOffsetY ) ; 
    float2 fTex9 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y + fOffsetY ) ; 
    
    f4ColorOut += 2 * tex2D [ 7 ] . Sample ( linearSampler , fTex1 ) ; 
    f4ColorOut += 2 * tex2D [ 7 ] . Sample ( linearSampler , fTex2 ) ; 
    f4ColorOut += 2 * tex2D [ 7 ] . Sample ( linearSampler , fTex3 ) ; 
    f4ColorOut += 2 * tex2D [ 7 ] . Sample ( linearSampler , fTex4 ) ; 
    f4ColorOut += 4 * tex2D [ 7 ] . Sample ( linearSampler , fTex5 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex6 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex7 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex8 ) ; 
    f4ColorOut += tex2D [ 7 ] . Sample ( linearSampler , fTex9 ) ; 
    return ( f4ColorOut *= 0.0625f ) ; 
} 

#line 121
float4 SobelOperatorLR ( float2 f2TexCoord ) 
{ 
    const float fStrength = 1.f ; 
    float fWidth , fHeight ; 
    tex2D [ 7 ] . GetDimensions ( fWidth , fHeight ) ; 
    float fOffsetX = 1.f / fWidth ; 
    float fOffsetY = 1.f / fHeight ; 
    float4 f4ColorOut = float4 ( 0.f , 0.f , 0.f , 1.f ) ; 
    float2 fTex1 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y ) ; 
    float2 fTex2 = float2 ( f2TexCoord . x , f2TexCoord . y + fOffsetY ) ; 
    float2 fTex3 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y ) ; 
    float2 fTex4 = float2 ( f2TexCoord . x , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex5 = float2 ( f2TexCoord . x , f2TexCoord . y ) ; 
    float2 fTex6 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex7 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex8 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y + fOffsetY ) ; 
    float2 fTex9 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y + fOffsetY ) ; 
    
    f4ColorOut += ( fStrength * - 2 ) * tex2D [ 7 ] . Sample ( linearSampler , fTex1 ) ; 
    
    f4ColorOut += ( fStrength * 2 ) * tex2D [ 7 ] . Sample ( linearSampler , fTex3 ) ; 
    
#line 144
    f4ColorOut += fStrength * tex2D [ 7 ] . Sample ( linearSampler , fTex6 ) ; 
    f4ColorOut += ( fStrength - 1 ) * tex2D [ 7 ] . Sample ( linearSampler , fTex7 ) ; 
    f4ColorOut += fStrength * tex2D [ 7 ] . Sample ( linearSampler , fTex8 ) ; 
    f4ColorOut += ( fStrength * - 1 ) * tex2D [ 7 ] . Sample ( linearSampler , fTex9 ) ; 
    return ( f4ColorOut ) ; 
} 

#line 155
float4 SobelOperatorUD ( float2 f2TexCoord ) 
{ 
    const float fStrength = 1.f ; 
    float fWidth , fHeight ; 
    tex2D [ 7 ] . GetDimensions ( fWidth , fHeight ) ; 
    float fOffsetX = 1.f / fWidth ; 
    float fOffsetY = 1.f / fHeight ; 
    float4 f4ColorOut = float4 ( 0.f , 0.f , 0.f , 1.f ) ; 
    float2 fTex1 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y ) ; 
    float2 fTex2 = float2 ( f2TexCoord . x , f2TexCoord . y + fOffsetY ) ; 
    float2 fTex3 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y ) ; 
    float2 fTex4 = float2 ( f2TexCoord . x , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex5 = float2 ( f2TexCoord . x , f2TexCoord . y ) ; 
    float2 fTex6 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex7 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y - fOffsetY ) ; 
    float2 fTex8 = float2 ( f2TexCoord . x - fOffsetX , f2TexCoord . y + fOffsetY ) ; 
    float2 fTex9 = float2 ( f2TexCoord . x + fOffsetX , f2TexCoord . y + fOffsetY ) ; 
    
    f4ColorOut += ( fStrength * - 2 ) * tex2D [ 7 ] . Sample ( linearSampler , fTex2 ) ; 
    
    f4ColorOut += ( fStrength * - 2 ) * tex2D [ 7 ] . Sample ( linearSampler , fTex4 ) ; 
    
    f4ColorOut += ( fStrength * - 1 ) * tex2D [ 7 ] . Sample ( linearSampler , fTex6 ) ; 
    f4ColorOut += ( fStrength * - 1 ) * tex2D [ 7 ] . Sample ( linearSampler , fTex7 ) ; 
    f4ColorOut += fStrength * tex2D [ 7 ] . Sample ( linearSampler , fTex8 ) ; 
    f4ColorOut += fStrength * tex2D [ 7 ] . Sample ( linearSampler , fTex9 ) ; 
    return ( f4ColorOut ) ; 
} 

float4 SobelOperatorLRAndUD ( float2 f2TexCoord ) 
{ 
    float4 f4ColorOutLR = float4 ( 0.f , 0.f , 0.f , 1.f ) ; 
    float4 f4ColorOutUD = float4 ( 0.f , 0.f , 0.f , 1.f ) ; 
    f4ColorOutLR = SobelOperatorLR ( f2TexCoord ) ; 
    f4ColorOutUD = SobelOperatorUD ( f2TexCoord ) ; 
    return ( abs ( f4ColorOutLR ) * abs ( f4ColorOutUD ) ) ; 
} 

#line 196
float4 PS_POST ( PS_INPUT_POST input ) : SV_Target 
{ 
    float4 f4ColorOut = tex2D [ 7 ] . Sample ( linearSampler , input . f2TexCoord ) ; 
    
    if ( f2rcpFrame . x ) 
    { 
        FxaaTex tex ; 
        tex . smpl = linearSampler ; 
        tex . tex = tex2D [ 7 ] ; 
        f4ColorOut = FxaaPixelShader ( input . f2TexCoord , 
        float4 ( 0.f , 0.f , 0.f , 0.f ) , 
        tex , 
        f2rcpFrame , 
        f4rcpFrameOpt ) ; 
    } 
    
    if ( uBlur ) 
    { 
        f4ColorOut = saturate ( f4ColorOut + BinomialFilter ( input . f2TexCoord , fBlurStrength ) ) ; 
    } 
    if ( uEnhancedEdges ) 
    { 
        f4ColorOut += SobelOperatorLRAndUD ( input . f2TexCoord ) ; 
        f4ColorOut . rgb *= 0.33f ; 
    } 
    if ( uMeanFilter ) 
    { 
        f4ColorOut += MeanFilter ( input . f2TexCoord ) ; 
        f4ColorOut . rgb *= 0.5f ; 
    } 
    
    f4ColorOut . a = 1.f ; 
    return f4ColorOut ; 
}  