#line 1 "\\\\?\\C:\\Users\\admin\\Documents\\Visual Studio 2010\\Projects\\Vektoria_2015-02-12a\\Vektoria\\trunk\\VektoriaApp\\shaders\\Source\\transperency.hlsl"


#line 1 "constant.h"


#line 10




#line 16


#line 20
cbuffer cbPerObject : register ( b0 ) 
{ 
    matrix g_mWorld : packoffset ( c0 ) ; 
} ; 

cbuffer cbPerCamera : register ( b1 ) 
{ 
    matrix g_mViewProj : packoffset ( c0 ) ; 
} ; 

cbuffer cbPerFrame : register ( b2 ) 
{ 
    matrix g_mView : packoffset ( c0 ) ; 
    matrix g_mViewInv : packoffset ( c4 ) ; 
    matrix g_mProjection : packoffset ( c8 ) ; 
    matrix g_mProjectionInv : packoffset ( c12 ) ; 
    matrix g_mProjectionInvViewport : packoffset ( c16 ) ; 
    float4 g_f4AmbientColorUp : packoffset ( c20 ) ; 
    float4 g_f4AmbientColorDown : packoffset ( c21 ) ; 
    float3 g_f3CameraPos : packoffset ( c22 ) ; 
    float g_fAlphaTest : packoffset ( c22 . w ) ; 
    uint g_uNumLights : packoffset ( c23 ) ; 
    uint g_uNumSpotLights : packoffset ( c23 . y ) ; 
    uint g_uWindowWidth : packoffset ( c23 . z ) ; 
    uint g_uWindowHeight : packoffset ( c23 . w ) ; 
    uint g_uMaxNumLightsPerTile : packoffset ( c24 ) ; 
    uint g_uMaxNumElementsPerTile : packoffset ( c24 . y ) ; 
    uint g_uNumTilesX : packoffset ( c24 . z ) ; 
    uint g_uNumTilesY : packoffset ( c24 . w ) ; 
    uint g_uMaxVPLs : packoffset ( c25 ) ; 
    uint g_uMaxNumVPLsPerTile : packoffset ( c25 . y ) ; 
    uint g_uMaxNumVPLElementsPerTile : packoffset ( c25 . z ) ; 
    float g_fVPLSpotStrength : packoffset ( c25 . w ) ; 
    float g_fVPLSpotRadius : packoffset ( c26 ) ; 
    float g_fVPLPointStrength : packoffset ( c26 . y ) ; 
    float g_fVPLPointRadius : packoffset ( c26 . z ) ; 
    float g_fVPLRemoveBackFaceContrib : packoffset ( c26 . w ) ; 
    float g_fVPLColorThreshold : packoffset ( c27 ) ; 
    float g_fVPLBrightnessThreshold : packoffset ( c27 . y ) ; 
    float g_fPerFramePad1 : packoffset ( c27 . z ) ; 
    float g_fPerFramePad2 : packoffset ( c27 . w ) ; 
} ; 

cbuffer cbShadowConstants : register ( b3 ) 
{ 
    matrix g_mPointShadowViewProj [ 12 ] [ 6 ] ; 
    matrix g_mSpotShadowViewProj [ 12 ] ; 
    float4 g_f4ShadowBias ; 
} 

cbuffer cbVPLConstants : register ( b4 ) 
{ 
    uint g_uNumVPLs ; 
    uint g_uVPLPad [ 3 ] ; 
} 

struct SVPLData 
{ 
    float4 f4Direction ; 
    float4 f4Color ; 
    float4 f4SourceLightDirection ; 
} ; 

#line 85
SamplerState g_Sampler : register ( s0 ) ; 
SamplerComparisonState g_ShadowSampler : register ( s1 ) ; 

#line 92
float4 ConvertProjToView ( float4 p ) 
{ 
    p = mul ( p , g_mProjectionInv ) ; 
    p /= p . w ; 
    return p ; 
} 

#line 100
float ConvertProjDepthToView ( float z ) 
{ 
    z = 1.f / ( z * g_mProjectionInv . _34 + g_mProjectionInv . _44 ) ; 
    return z ; 
} 

uint GetTileIndex ( float2 ScreenPos ) 
{ 
    float fTileRes = ( float ) 32 ; 
    uint nTileIdx = floor ( ScreenPos . x / fTileRes ) + floor ( ScreenPos . y / fTileRes ) * g_uNumTilesX ; 
    return nTileIdx ; 
} 

#line 116
void GetLightListInfo ( in Buffer < uint > PerTileLightIndexBuffer , in uint uMaxNumLightsPerTile , in uint uMaxNumElementsPerTile , 
in float4 SVPosition , out uint uFirstLightIndex , out uint uNumLights ) 
{ 
    uint nTileIndex = GetTileIndex ( SVPosition . xy ) ; 
    uint nStartIndex = uMaxNumElementsPerTile * nTileIndex ; 
    
#line 123
    uint uHalfZBitsHigh = PerTileLightIndexBuffer [ nStartIndex ] ; 
    uint uHalfZBitsLow = PerTileLightIndexBuffer [ nStartIndex + 1 ] ; 
    uint uHalfZBits = ( uHalfZBitsHigh << 16 ) | uHalfZBitsLow ; 
    float fHalfZ = asfloat ( uHalfZBits ) ; 
    
    float fViewPosZ = ConvertProjDepthToView ( SVPosition . z ) ; 
    
    uFirstLightIndex = ( fViewPosZ < fHalfZ ) ? ( nStartIndex + 4 ) : ( nStartIndex + 4 + uMaxNumLightsPerTile ) ; 
    uNumLights = ( fViewPosZ < fHalfZ ) ? PerTileLightIndexBuffer [ nStartIndex + 2 ] : PerTileLightIndexBuffer [ nStartIndex + 3 ] ; 
} 

#line 136
float HalfLambert ( float3 f3Vec1 , float3 f3Vec2 ) 
{ 
    float fProduct = dot ( f3Vec1 , f3Vec2 ) ; 
    fProduct *= 0.5f ; 
    fProduct += 0.5f ; 
    return fProduct ; 
} 

float BlinnPhongSpec ( float3 f3Normal , float3 f3LightDir , float fSpecpower ) 
{ 
    float3 f3HalfAngle = normalize ( f3Normal + f3LightDir ) ; 
    return pow ( saturate ( dot ( f3Normal , f3HalfAngle ) ) , fSpecpower ) ; 
} 

void SubsurfaceScattering ( in float4 f4CenterAndRadius , in float3 f3ToLight , in float3 f3LightColor , in float4 float4TexColor , 
in float fThickValue , in float4 f4SSSBRDFParams , in float4 f4ColorSSS , in float4 f4VertexPos , 
in float3 f3CamPos , in float3 f3Normal , in bool bPointLight , 
inout float3 f3LightColorSpecularResult , inout float3 f3LightDiffuseResult ) 
{ 
    const float fMaterialThickness = f4SSSBRDFParams . r ; 
    const float fRimScalar = f4SSSBRDFParams . b ; 
    const float fExtinctionCoefficientRed = f4ColorSSS . r ; 
    const float fExtinctionCoefficientGreen = f4ColorSSS . g ; 
    const float fExtinctionCoefficientBlue = f4ColorSSS . b ; 
    const float fSpecPower = 1.f ; 
    const float3 f3SpecColor = f3LightColorSpecularResult ; 
    const float4 f4TexColor = float4TexColor ; 
    float3 f3LightDir = normalize ( f3ToLight ) ; 
    float4 f4LightPos ; 
    float3 f3LightDirSSS ; 
    float4 f4FinColor ; 
    
    float3 f3EyeVector = normalize ( f3CamPos - f4VertexPos . xyz ) ; 
    f3LightDirSSS = - f3EyeVector ; 
    f4LightPos = f4CenterAndRadius ; 
    f4LightPos . w = 1.f ; 
    
    float fAttenuation = 10.f * ( 1.f / distance ( f4LightPos , f4VertexPos ) ) ; 
    
    const float3 f3Eye = normalize ( f3CamPos . xyz - f4VertexPos . xyz ) ; 
    float4 f4DotLN = HalfLambert ( f3LightDirSSS , f3Normal ) * fAttenuation ; 
    
    float3 f3IndirectLightComponent = ( float3 ) ( fMaterialThickness * max ( 0 , dot ( - f3Normal , f3LightDirSSS ) ) ) ; 
    f3IndirectLightComponent += HalfLambert ( - f3Eye , f3LightDirSSS ) * fMaterialThickness ; 
    f3IndirectLightComponent *= fAttenuation ; 
    f3IndirectLightComponent . r *= fExtinctionCoefficientRed ; 
    f3IndirectLightComponent . g *= fExtinctionCoefficientGreen ; 
    f3IndirectLightComponent . b *= fExtinctionCoefficientBlue ; 
    f3IndirectLightComponent . rgb *= fThickValue ; 
    
    float3 f3Rim = ( float3 ) ( 1.f - max ( 0.f , dot ( f3Normal , f3Eye ) ) ) ; 
    f3Rim *= f3Rim ; 
    f3Rim *= max ( 0.f , dot ( f3Normal , f3LightDirSSS ) ) * f3SpecColor ; 
    
    f4DotLN *= f4TexColor ; 
    
    f4FinColor = f4DotLN + float4 ( f3IndirectLightComponent , 1.f ) ; 
    f4FinColor . a = 1.f ; 
    f4FinColor . rgb += ( f3Rim * fRimScalar * fAttenuation * f4FinColor . a ) ; 
    f4FinColor . rgb += ( BlinnPhongSpec ( f3Normal , f3LightDirSSS , fSpecPower ) * fAttenuation * f3SpecColor * f4FinColor . a * .05f ) ; 
    f4FinColor . rgb *= f3LightColor ; 
    
    float fEdge = max ( dot ( normalize ( f3CamPos - f4VertexPos . xyz ) , f3Normal ) , 0 ) ; 
    [ branch ] 
    if ( ( fEdge < 0.8f ) && ( fMaterialThickness > 2.f ) ) 
    { 
        f3LightDiffuseResult . rgb *= f3IndirectLightComponent / 15.f ; 
        f3LightColorSpecularResult . rgb *= f3IndirectLightComponent / 15.f ; 
    } 
    else 
    { 
        f3LightDiffuseResult *= f4FinColor . xyz ; 
        f3LightColorSpecularResult *= f4FinColor . xyz ; 
    } 
} 

#line 213


#line 2 "\\\\?\\C:\\Users\\admin\\Documents\\Visual Studio 2010\\Projects\\Vektoria_2015-02-12a\\Vektoria\\trunk\\VektoriaApp\\shaders\\Source\\transperency.hlsl"


#line 1 "lightingconstants.h"


#line 8


#line 1 "texandtexflags.h"


Texture2D tex2D [ 7 ] : register ( t15 ) ; 

#line 7
cbuffer TexInfo : register ( b5 ) 
{ 
    float4 f4ColorAmbient : packoffset ( c0 ) ; 
    float fA : packoffset ( c1 ) ; 
    float fH : packoffset ( c1 . y ) ; 
    float fBumpStrength : packoffset ( c1 . z ) ; 
    float frTransparency : packoffset ( c1 . w ) ; 
    float4 f4ColorSSS : packoffset ( c2 ) ; 
    float4 f4SSSBRDFParams : packoffset ( c3 ) ; 
    uint uImage : packoffset ( c4 ) ; 
    uint uGlow : packoffset ( c4 . y ) ; 
    uint uSpecular : packoffset ( c4 . z ) ; 
    uint uBump : packoffset ( c4 . w ) ; 
    uint uImageBlack : packoffset ( c5 ) ; 
    uint uGlowAsImage : packoffset ( c5 . y ) ; 
    uint uSpecularAsImage : packoffset ( c5 . z ) ; 
    uint uHeightAsImage : packoffset ( c5 . w ) ; 
    uint uImageWhite : packoffset ( c6 ) ; 
    uint uGlowWhite : packoffset ( c6 . y ) ; 
    uint uSpecularWhite : packoffset ( c6 . z ) ; 
    uint uHeight : packoffset ( c6 . w ) ; 
    uint uShadingOn : packoffset ( c7 ) ; 
    uint uGlowAsAmbient : packoffset ( c7 . y ) ; 
    uint uChromaKeying : packoffset ( c7 . z ) ; 
    uint uEnvironment : packoffset ( c7 . w ) ; 
    uint uPOM : packoffset ( c8 ) ; 
    uint uTexBRDF : packoffset ( c8 . y ) ; 
    uint uTexSSS : packoffset ( c8 . z ) ; 
    uint uReflectionMap : packoffset ( c8 . w ) ; 
    uint uixPos : packoffset ( c9 ) ; 
    uint uiyPos : packoffset ( c9 . y ) ; 
    uint uixPics : packoffset ( c9 . z ) ; 
    uint uiyPics : packoffset ( c9 . w ) ; 
    float fSpecularRoughness : packoffset ( c10 . x ) ; 
    float fSpecularIOR : packoffset ( c10 . y ) ; 
    uint uPad1 : packoffset ( c10 . z ) ; 
    uint uPad2 : packoffset ( c10 . w ) ; 
} 

cbuffer ViewportArt : register ( b6 ) 
{ 
    float4 f4ColorViewportOutline : packoffset ( c0 ) ; 
    float4 f4FogParams : packoffset ( c1 ) ; 
    matrix mColorModification : packoffset ( c2 ) ; 
    
    uint uStyleColor : packoffset ( c6 ) ; 
    uint uStyleHalfTransparent : packoffset ( c6 . y ) ; 
    uint uStylePopart : packoffset ( c6 . z ) ; 
    uint uStyleOutlining : packoffset ( c6 . w ) ; 
    uint uStyleMonochrome : packoffset ( c7 ) ; 
    uint uStyleOwn : packoffset ( c7 . y ) ; 
    uint uStyleFog : packoffset ( c7 . z ) ; 
    uint uPad0 : packoffset ( c7 . w ) ; 
} 

#line 9 "lightingconstants.h"


#line 1 "ggxlighting.h"
float G1V ( float fDotNV , float fK ) 
{ 
    return 1.f / ( fDotNV * ( 1.f - fK ) + fK ) ; 
} 

float fLightingFuncGGX ( float3 f3N , float3 f3V , float3 f3L , float fRoughness , float fF0 ) 
{ 
    f3N = normalize ( f3N ) ; 
    
    float fAlpha = fRoughness * fRoughness ; 
    float3 f3H = normalize ( f3V + f3L ) ; 
    
    float fDotNL = saturate ( dot ( f3N , f3L ) ) ; 
    float fDotNV = saturate ( dot ( f3N , f3V ) ) ; 
    float fDotNH = saturate ( dot ( f3N , f3H ) ) ; 
    float fDotLH = saturate ( dot ( f3L , f3H ) ) ; 
    
    float fF , fD , fVis ; 
    
#line 21
    float fAlphaSqr = fAlpha * fAlpha ; 
    const float fPi = 3.14159f ; 
    float fDenom = fDotNH * fDotNH * ( fAlphaSqr - 1.f ) + 1.f ; 
    fD = fAlphaSqr / ( fPi * fDenom * fDenom ) ; 
    
#line 27
    float fDotLH5 = pow ( 1.f - fDotLH , 5 ) ; 
    fF = fF0 + ( 1.f - fF0 ) * ( fDotLH5 ) ; 
    
#line 31
    float fK = fAlpha / 2.f ; 
    fVis = G1V ( fDotNL , fK ) * G1V ( fDotNV , fK ) ; 
    
    float fSpecular = fDotNL * fD * fF * fVis ; 
    return fSpecular ; 
} 

#line 89
float SchlickFresnel ( float fu ) 
{ 
    float fm = clamp ( 1.f - fu , 0 , 1 ) ; 
    float fm2 = fm * fm ; 
    return fm2 * fm2 * fm ; 
} 

float fDiffuseLighting ( float3 f3N , float3 f3V , float3 f3L , float fRoughness ) 
{ 
    float3 f3H = normalize ( f3V + f3L ) ; 
    float fDotNL = saturate ( dot ( f3N , f3L ) ) ; 
    float fDotLH = saturate ( dot ( f3L , f3H ) ) ; 
    float fDotNV = saturate ( dot ( f3N , f3V ) ) ; 
    float fFL = SchlickFresnel ( fDotNL ) , fFV = SchlickFresnel ( fDotNV ) ; 
    float fFd90 = 0.5f + 2.f * fDotLH * fDotLH * fRoughness ; 
    float fPi = 3.14159f ; 
    return ( 1 / fPi * ( ( lerp ( 1 , fFd90 , fFL ) * lerp ( 1 , fFd90 , fFV ) ) ) ) ; 
} 

#line 112
static const float3 f3BaseColor = float3 ( 0.01f , 0.01f , 0.01f ) ; 
static const float fSpecular = 0.8f ; 
static const float fSpecularTint = 0.f ; 
static const float fMetallic = 0.f ; 
static const float fSubSurface = 0.f ; 
static const float fAnistropic = 0.f ; 
static const float fSheen = 0.f ; 
static const float fSheenTint = 0.f ; 
static const float fClearCoat = 0.f ; 
static const float fClearCoatGloss = 1.f ; 

float Sqr ( float fx ) 
{ 
    return fx * fx ; 
} 

float GTR1 ( float fDotNH , float fa ) 
{ 
    const float fPI = 3.14159265358979323846f ; 
    if ( fa >= 1.f ) return 1 / fPI ; 
    float fa2 = fa * fa ; 
    float fT = 1.f + ( fa2 - 1.f ) * fDotNH * fDotNH ; 
    return ( fa2 - 1.f ) / ( fPI * log ( fa2 ) * fT ) ; 
} 

float GTR2 ( float fDotNH , float fa ) 
{ 
    const float fPI = 3.14159265358979323846f ; 
    float fa2 = fa + fa ; 
    float fT = 1.f + ( fa2 - 1.f ) * fDotNH * fDotNH ; 
    return fa2 / ( fPI * fT * fT ) ; 
} 

float GTR2Aniso ( float fDotNH , float fDotHX , float fDotHY , float fax , float fay ) 
{ 
    const float fPI = 3.14159265358979323846f ; 
    return 1.f / ( fPI * fax * fay * Sqr ( Sqr ( fDotHX / fax ) + Sqr ( fDotHY / fay ) + fDotNH * fDotNH ) ) ; 
} 

float SmithGGX ( float fDotNV , float fAlphaG ) 
{ 
    float fa = fAlphaG * fAlphaG ; 
    float fb = fDotNV * fDotNV ; 
    return 1 / ( fDotNV + Sqr ( fa + fb - fa * fb ) ) ; 
} 

float3 Mon2Lin ( float3 f3Color ) 
{ 
    return float3 ( saturate ( pow ( f3Color . x , 2.2f ) ) , saturate ( pow ( f3Color . y , 2.2f ) ) , saturate ( pow ( f3Color . z , 2.2f ) ) ) ; 
} 

float3 BRDF ( float3 f3L , float3 f3V , float3 f3N , float fRoughness , float fF0 , float3 f3Color ) 
{ 
    f3L = f3L ; 
    f3N = f3N ; 
    float3 f3C1 = cross ( f3N , float3 ( 0.f , 0.f , 1.f ) ) ; 
    float3 f3C2 = cross ( f3N , float3 ( 0.f , 1.f , 0.f ) ) ; 
    float3 f3X ; 
    [ branch ] 
    if ( length ( f3C1 ) > length ( f3C2 ) ) 
    { 
        f3X = normalize ( f3C1 ) ; 
    } 
    else 
    { 
        f3X = normalize ( f3C2 ) ; 
    } 
    float3 f3Y = normalize ( - cross ( f3N , f3X ) ) ; 
    
    const float fPI = 3.141592 ; 
    float fDotNL = ( dot ( f3N , f3L ) ) ; 
    float fDotNV = ( dot ( f3N , f3V ) ) ; 
    
    if ( fDotNL < 0 ) return float3 ( 0.f , 0.f , 0.f ) ; 
    if ( fDotNV < 0 ) return float3 ( 0.f , 0.f , 0.f ) ; 
    float3 f3H = normalize ( f3L + f3V ) ; 
    float fDotNH = ( dot ( f3N , f3H ) ) ; 
    float fDotLH = saturate ( dot ( f3L , f3H ) ) ; 
    
    float3 f3CdLin = Mon2Lin ( f3Color ) ; 
    float fCdLum = 0.3f * f3CdLin . x + 0.6f * f3CdLin . y + 0.1f * f3CdLin . z ; 
    
    float3 f3CTint = fCdLum > 0 ? f3CdLin / fCdLum : float3 ( 1.f , 1.f , 1.f ) ; 
    
    float3 f3CSpec0 = lerp ( 0.5f * 0.08f * lerp ( float3 ( 1.f , 1.f , 1.f ) , f3CTint , 0.5f ) , f3CdLin , 0.f ) ; 
    
    float3 f3CSheen = lerp ( float3 ( 1.f , 1.f , 1.f ) , f3CTint , 0.f ) ; 
    
    float fFL = SchlickFresnel ( fDotNL ) , fFV = SchlickFresnel ( fDotNV ) ; 
    float fFd90 = 0.5f + 2 * fDotLH * fDotLH * fRoughness ; 
    float fFd = ( lerp ( 1 , fFd90 , fFL ) * lerp ( 1 , fFd90 , fFV ) ) ; 
    
    float fFss90 = fDotLH * fDotLH * fRoughness ; 
    float fFss = lerp ( 1 , fFss90 , fFL ) * lerp ( 1 , fFss90 , fFV ) ; 
    float fss = 1.5f * ( fFss * ( 1 / ( fDotNL + fDotNV ) - 0.5f ) + 0.5f ) ; 
    
#line 209
    float fAspect = sqrt ( 1.f - 0.f * 0.9f ) ; 
    float fax = max ( 0.001f , Sqr ( fRoughness ) / fAspect ) ; 
    float fay = max ( 0.001f , Sqr ( fRoughness ) * fAspect ) ; 
    float fDs = GTR2Aniso ( fDotNH , dot ( f3H , f3X ) , dot ( f3H , f3Y ) , fax , fay ) ; 
    float fFH = SchlickFresnel ( fDotLH ) ; 
    float3 f3Fs = lerp ( f3CSpec0 , float3 ( 1.f , 1.f , 1.f ) , fFH ) ; 
    float fRoughG = Sqr ( fRoughness * 0.5f + 0.5f ) ; 
    float fGs = SmithGGX ( fDotNL , fRoughG ) * SmithGGX ( fDotNV , fRoughG ) ; 
    
    float3 f3FSheen = fFH * 0.f * f3CSheen ; 
    
    float fDr = GTR1 ( fDotNH , lerp ( 0.1f , 0.001 , 1.f ) ) ; 
    float fFr = lerp ( fF0 , 1.f , fFH ) ; 
    float fGr = SmithGGX ( fDotNL , 0.25f ) * SmithGGX ( fDotNV , 0.25f ) ; 
    
    return ( ( ( 1 / fPI ) * lerp ( fFd , fss , 0.f ) * f3CdLin + 0.f ) * ( 1.f - 0.f ) + fGs * f3Fs * fDs + 0.25f * 
    0.f * fGr * fFr * fDr ) ; 
    
} 

#line 13 "lightingconstants.h"
Texture2D g_PointShadowAtlas : register ( t13 ) ; 
Texture2D g_SpotShadowAtlas : register ( t14 ) ; 

#line 18
int Vector3ToFace ( float3 f3Vec ) 
{ 
    int iFace = 0 ; 
    float fx = f3Vec . x ; 
    float fy = f3Vec . y ; 
    float fz = f3Vec . z ; 
    if ( ( abs ( fx ) > abs ( fy ) ) && ( abs ( fx ) > abs ( fz ) ) ) 
    { 
        if ( fx >= 0 ) 
        { 
            iFace = 0 ; 
        } 
        else 
        { 
            iFace = 1 ; 
        } 
    } 
    else if ( ( abs ( fy ) > abs ( fx ) ) && ( abs ( fy ) > abs ( fz ) ) ) 
    { 
        if ( fy >= 0 ) 
        { 
            iFace = 2 ; 
        } 
        else 
        { 
            iFace = 3 ; 
        } 
    } 
    else 
    { 
        if ( fz >= 0 ) 
        { 
            iFace = 4 ; 
        } 
        else 
        { 
            iFace = 5 ; 
        } 
    } 
    return iFace ; 
} 

float RandomGelfond ( float2 f2p ) 
{ 
    const float2 r = float2 ( 23.1406926327792690 , 
    2.6651441426902251 ) ; 
    return ( frac ( cos ( fmod ( 123456789. , 1e-7 + 256. * dot ( f2p , r ) ) ) ) ) ; 
} 

#line 68
float2 TexOffset2 ( int iu , int iv , float fWidth , float fHeight , float fSampleOffset , float2 f2Pos ) 
{ 
    const float frand = RandomGelfond ( f2Pos ) ; 
    return float2 ( ( iu * 1.f / ( fWidth * ( fSampleOffset + frand ) ) ) , ( iv * 1.f / ( fHeight * ( fSampleOffset + frand ) ) ) ) ; 
} 

float FilterShadow ( Texture2D atlas , float3 f3uv ) 
{ 
    float fShadow = 0.f ; 
    
    static const int iKernelLevel = 3 ; 
    static const int iKernelWidth = 2 * iKernelLevel + 1 ; 
    [ unroll ( iKernelWidth ) ] for ( int i = - iKernelLevel ; i <= iKernelLevel ; i ++ ) 
    { 
        [ unroll ( iKernelWidth ) ] for ( int j = - iKernelLevel ; j <= iKernelLevel ; j ++ ) 
        { 
            fShadow += atlas . SampleCmpLevelZero ( g_ShadowSampler , f3uv . xy , f3uv . z , int2 ( i , j ) ) . r ; 
        } 
    } 
    
    fShadow /= ( iKernelWidth * iKernelWidth ) ; 
    return fShadow ; 
} 

static const uint uNumDiscSamples = 16 ; 
static const float2 f2DiscKernel [ uNumDiscSamples ] = { 
    float2 ( 0.2069841f , 0.2245269f ) , 
    float2 ( 0.525808f , - 0.2310817f ) , 
    float2 ( 0.1383943f , 0.9056122f ) , 
    float2 ( 0.6633009f , 0.5129843f ) , 
    float2 ( - 0.4002792f , 0.3727058f ) , 
    float2 ( 0.07912822f , - 0.6512921f ) , 
    float2 ( - 0.7726067f , - 0.5151217f ) , 
    float2 ( - 0.3843193f , - 0.1494132f ) , 
    float2 ( - 0.9107782f , 0.2500633f ) , 
    float2 ( 0.6940153f , - 0.7098927f ) , 
    float2 ( - 0.1964669f , - 0.379389f ) , 
    float2 ( - 0.4769286f , 0.1840863f ) , 
    float2 ( - 0.247328f , - 0.8798459f ) , 
    float2 ( 0.4206541f , - 0.714772f ) , 
    float2 ( 0.5829348f , - 0.09794202f ) , 
    float2 ( 0.3691838f , 0.4140642f ) 
} ; 

float FilterShadowRand ( Texture2D atlas , float3 f3uv ) 
{ 
    float fShadow = 0.f ; 
    static const float fDivisor = 0.0002441f ; 
    static const int iKernelLevel = 2 ; 
    static const int iKernelWidth = 2 * iKernelLevel + 1 ; 
    [ unroll ( iKernelWidth ) ] for ( int i = - iKernelLevel ; i <= iKernelLevel ; i ++ ) 
    { 
        [ unroll ( iKernelWidth ) ] for ( int j = - iKernelLevel ; j <= iKernelLevel ; j ++ ) 
        { 
            float fFlatNum = i + iKernelLevel + j + iKernelLevel ; 
            
#line 126
            fShadow += atlas . SampleCmpLevelZero ( g_ShadowSampler , 
            f3uv . xy + f2DiscKernel [ fFlatNum ] * fDivisor , 
            f3uv . z , int2 ( i , j ) ) . r ; 
        } 
    } 
    
    fShadow /= ( iKernelWidth * iKernelWidth ) ; 
    return fShadow ; 
} 

float ApplyPointShadow ( uint uShadowIndex , in float3 f3Position , float3 f3LightDir , in float fDistanceTerm , in float2 f2TexCoordDiff ) 
{ 
    float3 f3uv = - f3LightDir ; 
    f3uv . z = - f3uv . z ; 
    
    int iFace = Vector3ToFace ( f3uv . xyz ) ; 
    
    float4 f4ShadowTexCoord = mul ( float4 ( f3Position , 1.f ) , g_mPointShadowViewProj [ uShadowIndex ] [ iFace ] ) ; 
    f4ShadowTexCoord . xyz = f4ShadowTexCoord . xyz / f4ShadowTexCoord . w ; 
    
    f4ShadowTexCoord . x = f4ShadowTexCoord . x / 2.f + 0.5f ; 
    f4ShadowTexCoord . y = f4ShadowTexCoord . y / - 2.f + 0.5f ; 
    
    f4ShadowTexCoord . x += iFace ; 
    f4ShadowTexCoord . x *= rcp ( 6 ) ; 
    
    f4ShadowTexCoord . y += uShadowIndex ; 
    f4ShadowTexCoord . y *= rcp ( 12 ) ; 
    
    f4ShadowTexCoord . z -= lerp ( 10.f , .1f , saturate ( 5 * fDistanceTerm ) ) * g_f4ShadowBias . w ; 
    
    return FilterShadow ( g_PointShadowAtlas , f4ShadowTexCoord . xyz ) ; 
} 

float ApplySpotShadow ( uint uShadowIndex , in float3 f3Position ) 
{ 
    float4 f4ShadowTexCoord = mul ( float4 ( f3Position , 1.f ) , g_mSpotShadowViewProj [ uShadowIndex ] ) ; 
    f4ShadowTexCoord . xyz = f4ShadowTexCoord . xyz / f4ShadowTexCoord . w ; 
    
    f4ShadowTexCoord . x = f4ShadowTexCoord . x / 2.f + 0.5f ; 
    f4ShadowTexCoord . y = f4ShadowTexCoord . y / - 2.f + 0.5f ; 
    
    f4ShadowTexCoord . x += uShadowIndex ; 
    f4ShadowTexCoord . x *= rcp ( 12 ) ; 
    
    f4ShadowTexCoord . z -= g_f4ShadowBias . w * 6 ; 
    
    return FilterShadow ( g_SpotShadowAtlas , f4ShadowTexCoord . xyz ) ; 
} 

#line 177
void ApplyPointLighting ( uniform bool bShadow , in Buffer < float4 > pointLightCenterAndRadiusBuffer , 
in Buffer < float4 > pointLightColorBuffer , 
in uint uLightIndex , in float3 f3Position , 
in float3 f3Norm , in float3 f3ViewDir , 
in float2 f2TexCoordDiff , in float4 f4SpecMapCol , 
in float4 f4DiffMapColor , 
out float3 f3LightColorDiffuseResult , 
out float3 f3LightColorSpecularResult ) 
{ 
    float4 f4CenterAndRadius = pointLightCenterAndRadiusBuffer [ uLightIndex ] ; 
    
    float3 f3ToLight = f4CenterAndRadius . xyz - f3Position ; 
    float3 f3LightDir = normalize ( f3ToLight ) ; 
    float fLightDistance = length ( f3ToLight ) ; 
    
    f3LightColorDiffuseResult = float3 ( 0.f , 0.0f , 0.f ) ; 
    f3LightColorSpecularResult = float3 ( 0.f , 0.f , 0.f ) ; 
    
    float fRad = f4CenterAndRadius . w ; 
    if ( fLightDistance < fRad ) 
    { 
        float fx = fLightDistance / fRad ; 
        
#line 204
        float fFallOff = fRad * ( saturate ( pow ( ( 1.f - pow ( fx , 4 ) ) , 2 ) ) ) / ( ( fLightDistance * fLightDistance ) + 1 ) ; 
        
        f3LightColorDiffuseResult = pointLightColorBuffer [ uLightIndex ] . rgb * saturate ( dot ( f3LightDir , f3Norm ) ) * fFallOff ; 
        f3LightColorDiffuseResult *= fH ; 
        float3 f3HalfAngle = normalize ( f3ViewDir + f3LightDir ) ; 
        
        float fSpecMul = fLightingFuncGGX ( f3Norm , f3ViewDir , f3ToLight , fSpecularRoughness , fSpecularIOR ) ; 
        f3LightColorSpecularResult = pointLightColorBuffer [ uLightIndex ] . rgb * fSpecMul * fFallOff ; 
        
#line 215
        [ branch ] 
        if ( uSpecularWhite ) 
        f3LightColorSpecularResult = 2 * ( f3LightColorSpecularResult * f3LightColorDiffuseResult ) ; 
        else if ( uSpecularAsImage ) 
        f3LightColorSpecularResult = 2 * f4SpecMapCol . xyz * ( f3LightColorSpecularResult * f3LightColorDiffuseResult ) ; 
        else 
        f3LightColorSpecularResult = 2 * f4SpecMapCol . xyz * ( f3LightColorSpecularResult * f3LightColorDiffuseResult ) ; 
        
        if ( bShadow ) 
        { 
            float fShadowRes = ApplyPointShadow ( uLightIndex , f3Position , f3LightDir , fx , f2TexCoordDiff ) ; 
            f3LightColorDiffuseResult *= fShadowRes ; 
            f3LightColorSpecularResult *= fShadowRes ; 
        } 
        
        f3LightColorDiffuseResult *= 16 ; 
        f3LightColorSpecularResult *= 16 ; 
    } 
} 

#line 257
void ApplySpotLighting ( uniform bool bShadow , in Buffer < float4 > spotLightCenterAndRadiusBuffer , 
in Buffer < float4 > spotLightColorBuffer , 
in Buffer < float4 > spotLightSpotParamsBuffer , 
in uint uLightIndex , in float3 f3Position , 
in float3 f3Norm , in float3 f3ViewDir , 
in float2 f2TexCoord , in float4 f4SpecMapCol , 
in float4 f4DiffMapColor , 
out float3 f3LightColorDiffuseResult , 
out float3 f3LightColorSpecularResult ) 
{ 
    float4 f4BoundingSphereCenterAndRadius = spotLightCenterAndRadiusBuffer [ uLightIndex ] ; 
    float4 f4SpotParams = spotLightSpotParamsBuffer [ uLightIndex ] ; 
    
#line 271
    float3 f3SpotLightDir ; 
    f3SpotLightDir . xy = f4SpotParams . xy ; 
    f3SpotLightDir . z = sqrt ( 1.f - f3SpotLightDir . x * f3SpotLightDir . x - f3SpotLightDir . y * f3SpotLightDir . y ) ; 
    
#line 276
    f3SpotLightDir . z = ( f4SpotParams . z > 0 ) ? f3SpotLightDir . z : - f3SpotLightDir . z ; 
    
    float3 f3LightPosition = f4BoundingSphereCenterAndRadius . xyz - f4BoundingSphereCenterAndRadius . w * f3SpotLightDir ; 
    
    float3 f3ToLight = f3LightPosition - f3Position ; 
    float3 f3ToLightNormalized = normalize ( f3ToLight ) ; 
    float fLightDistance = length ( f3ToLight ) ; 
    float fCosineOfCurrentAngle = dot ( - f3ToLightNormalized , f3SpotLightDir ) ; 
    
    f3LightColorDiffuseResult = float3 ( 0.f , 0.f , 0.f ) ; 
    f3LightColorSpecularResult = float3 ( 0.f , 0.f , 0.f ) ; 
    
    float fRad = f4SpotParams . w ; 
    float fCosineOfConeAngle = ( f4SpotParams . z > 0.f ) ? f4SpotParams . z : - f4SpotParams . z ; 
    
    if ( fLightDistance < fRad && fCosineOfCurrentAngle > fCosineOfConeAngle ) 
    { 
        float fRadialAttenuation = ( fCosineOfCurrentAngle - fCosineOfConeAngle ) / ( 1.f - fCosineOfCurrentAngle ) ; 
        fRadialAttenuation = saturate ( fRadialAttenuation * fRadialAttenuation ) ; 
        
        float fx = fLightDistance / fRad ; 
        
#line 303
        float fFallOff = fRad * ( saturate ( pow ( ( 1.f - pow ( fx , 4 ) ) , 2 ) ) ) / ( ( fLightDistance * fLightDistance ) + 1 ) ; 
        f3LightColorDiffuseResult = spotLightColorBuffer [ uLightIndex ] . rgb * saturate ( dot ( f3ToLightNormalized , f3Norm ) ) 
        * fFallOff * fRadialAttenuation ; 
        f3LightColorDiffuseResult *= fH ; 
        float3 f3HalfAngle = normalize ( f3ViewDir + f3ToLightNormalized ) ; 
        
#line 310
        float fSpecMul = fLightingFuncGGX ( f3Norm , - f3ViewDir , f3ToLight , fSpecularRoughness , fSpecularIOR ) ; 
        f3LightColorSpecularResult = spotLightColorBuffer [ uLightIndex ] . rgb * fSpecMul * fFallOff * fRadialAttenuation ; 
        
#line 316
        [ branch ] 
        if ( uSpecularWhite ) 
        f3LightColorSpecularResult = 2 * ( f3LightColorSpecularResult * f3LightColorDiffuseResult ) ; 
        else if ( uSpecularAsImage ) 
        f3LightColorSpecularResult = 2 * f4SpecMapCol . xyz * ( f3LightColorSpecularResult * f3LightColorDiffuseResult ) ; 
        else 
        f3LightColorSpecularResult = 2 * f4SpecMapCol . xyz * ( f3LightColorSpecularResult * f3LightColorDiffuseResult ) ; 
        
        if ( bShadow ) 
        { 
            float fShadowRes = ApplySpotShadow ( uLightIndex , f3Position ) ; 
            f3LightColorDiffuseResult *= fShadowRes ; 
            f3LightColorSpecularResult *= fShadowRes ; 
        } 
        
        f3LightColorDiffuseResult *= 16.f ; 
        f3LightColorSpecularResult *= 16.f ; 
    } 
} 

void ApplyVPLLighting ( in StructuredBuffer < float4 > vplCenterAndRadiusBuffer , in StructuredBuffer < SVPLData > vplDataBuffer , 
in uint uLightIndex , in float3 f3Position , in float3 f3Norm , 
out float3 f3LightColorDiffuseResult ) 
{ 
    float4 f4CenterAndRadius = vplCenterAndRadiusBuffer [ uLightIndex ] ; 
    SVPLData data = vplDataBuffer [ uLightIndex ] ; 
    
    float3 f3ToLight = f4CenterAndRadius . xyz - f3Position ; 
    float3 f3LightDir = normalize ( f3ToLight ) ; 
    float fLightDistance = length ( f3ToLight ) ; 
    
    f3LightColorDiffuseResult = float3 ( 0.f , 0.f , 0.f ) ; 
    
    float fRad = f4CenterAndRadius . w ; 
    float fVPLNormalDotDir = max ( 0.f , dot ( data . f4Direction . xyz , - f3LightDir ) ) ; 
    
    if ( fLightDistance < fRad && fVPLNormalDotDir > 0.f ) 
    { 
        float3 f3LightColor = data . f4Color . rgb ; 
        
        float fx = fLightDistance / fRad ; 
        float fFallOff = smoothstep ( 1.f , 0.f , fx ) ; 
        
        float fSourceLightDotL = dot ( data . f4SourceLightDirection . xyz , f3Norm ) ; 
        if ( fSourceLightDotL < 0.f ) 
        { 
            fSourceLightDotL = 1.f + ( fSourceLightDotL / g_fVPLRemoveBackFaceContrib ) ; 
        } 
        else 
        { 
            fSourceLightDotL = 1.f ; 
        } 
        
        f3LightColorDiffuseResult = f3LightColor * saturate ( dot ( f3LightDir , f3Norm ) ) * fFallOff * fVPLNormalDotDir * fSourceLightDotL ; 
    } 
} 

#line 8 "\\\\?\\C:\\Users\\admin\\Documents\\Visual Studio 2010\\Projects\\Vektoria_2015-02-12a\\Vektoria\\trunk\\VektoriaApp\\shaders\\Source\\transperency.hlsl"
Buffer < float4 > g_pointLightCenterAndRadiusBuffer : register ( t2 ) ; 
Buffer < float4 > g_pointLightColorBuffer : register ( t3 ) ; 
Buffer < uint > g_perTilePointLightIndexBuffer : register ( t4 ) ; 

Buffer < float4 > g_spotLightCenterAndRadiusBuffer : register ( t5 ) ; 
Buffer < float4 > g_spotLightColorBuffer : register ( t6 ) ; 
Buffer < float4 > g_spotLightParamsBuffer : register ( t7 ) ; 
Buffer < uint > g_perTileSpotLightIndexBuffer : register ( t8 ) ; 

#line 19
struct VS_INPUT_ALPHA_BLENDED 
{ 
    float4 f4Pos : POSITION ; 
    float3 f3Normal : NORMAL ; 
    float2 f2TexCoord : TEXCOORD ; 
    float3 f3Tangent : TANGENT ; 
    float3 f3Bitangent : BITANGENT ; 
} ; 

struct VS_OUTPUT_ALPHA_BLENDED 
{ 
    float4 f4Pos : SV_POSITION ; 
    float3 f3Normal : NORMAL ; 
    float3 f3VertexPos : TEXCOORD0 ; 
    float2 f2TexCoord : TEXCOORD1 ; 
    float3 f3Tangent : TANGENT ; 
    float3 f3Bitangent : BITANGENT ; 
    float3 f3CamPos : TEXCOORD2 ; 
} ; 

struct VS_OUTPUT_ALPHA_BLENDED_DEPTH 
{ 
    float4 f4Pos : SV_POSITION ; 
} ; 

#line 46
void ApplyPointLightingTwoSided ( in uint uLightIndex , in float3 f3Position , in float3 f3Norm , in float3 f3ViewDir , 
in float4 f4SpecMapCol , in float2 f2TexCoord , 
out float3 f3LightColorDiffuseFrontRes , out float3 f3LightColorSpecularFrontRes , 
out float3 f3LightColorDiffuseBackRes , out float3 f3LightColorSpecularBackRes ) 
{ 
    float4 f4CenterAndRadius = g_pointLightCenterAndRadiusBuffer [ uLightIndex ] ; 
    
    float3 f3ToLight = f4CenterAndRadius . xyz - f3Position . xyz ; 
    float3 f3LightDir = normalize ( f3ToLight ) ; 
    float fLightDistance = length ( f3ToLight ) ; 
    
    f3LightColorDiffuseFrontRes = float3 ( 0.f , 0.f , 0.f ) ; 
    f3LightColorSpecularFrontRes = float3 ( 0.f , 0.f , 0.f ) ; 
    f3LightColorDiffuseBackRes = float3 ( 0.f , 0.f , 0.f ) ; 
    f3LightColorSpecularBackRes = float3 ( 0.f , 0.f , 0.f ) ; 
    
    float fRad = f4CenterAndRadius . w ; 
    if ( fLightDistance < fRad ) 
    { 
        float fx = fLightDistance / fRad ; 
        
#line 70
        float fFallOff = fRad * ( saturate ( pow ( ( 1.f - pow ( fx , 4 ) ) , 2 ) ) ) / ( ( fLightDistance * fLightDistance ) + 1 ) ; 
        
        float3 f3LightColor = g_pointLightColorBuffer [ uLightIndex ] . rgb ; 
        
        f3LightColorDiffuseFrontRes = f3LightColor * saturate ( dot ( f3LightDir , f3Norm ) ) * fFallOff ; 
        f3LightColorDiffuseFrontRes *= fH ; 
        f3LightColorDiffuseFrontRes *= 10 ; 
        float3 f3HalfAngle = normalize ( f3ViewDir + f3LightDir ) ; 
        
#line 80
        float fSpecMul = fLightingFuncGGX ( f3Norm , f3ViewDir , f3ToLight , fSpecularRoughness , fSpecularIOR ) ; 
        f3LightColorSpecularFrontRes = g_pointLightColorBuffer [ uLightIndex ] . rgb * fSpecMul * fFallOff ; 
        f3LightColorSpecularFrontRes *= 10 ; 
        
        f3LightColorDiffuseBackRes = f3LightColor * saturate ( dot ( f3LightDir , - f3Norm ) ) * fFallOff ; 
        f3LightColorDiffuseBackRes *= fH ; 
        f3LightColorDiffuseBackRes *= 10 ; 
        
#line 89
        f3LightColorSpecularBackRes = g_pointLightColorBuffer [ uLightIndex ] . rgb * fSpecMul * fFallOff ; 
        f3LightColorSpecularBackRes *= 10 ; 
        
#line 94
        [ branch ] 
        if ( uSpecularWhite ) 
        f3LightColorSpecularFrontRes = 2 * ( f3LightColorSpecularFrontRes * f3LightColorDiffuseFrontRes ) ; 
        else if ( uSpecularAsImage ) 
        f3LightColorSpecularFrontRes = 2 * f4SpecMapCol . xyz * ( f3LightColorSpecularFrontRes * f3LightColorDiffuseFrontRes ) ; 
        else 
        f3LightColorSpecularFrontRes = 2 * f4SpecMapCol . xyz * ( f3LightColorSpecularFrontRes * f3LightColorDiffuseFrontRes ) ; 
        
        
        float fShadowRes = ApplyPointShadow ( uLightIndex , f3Position , f3LightDir , fx , f2TexCoord ) ; 
        f3LightColorDiffuseFrontRes *= fShadowRes ; 
        f3LightColorSpecularFrontRes *= fShadowRes ; 
        f3LightColorDiffuseBackRes *= fShadowRes ; 
        f3LightColorSpecularBackRes *= fShadowRes ; 
        
    } 
} 

void ApplySpotLightingTwoSided ( in uint uLightIndex , in float3 f3Position , in float3 f3Norm , in float3 f3ViewDir , 
in float4 f4SpecMapCol , 
out float3 f3LightColorDiffuseFrontRes , out float3 f3LightColorSpecularFrontRes , 
out float3 f3LightColorDiffuseBackRes , out float3 f3LightColorSpecularBackRes ) 
{ 
    float4 f4BoundingSphereAndRadius = g_spotLightCenterAndRadiusBuffer [ uLightIndex ] ; 
    float4 f4SpotParams = g_spotLightParamsBuffer [ uLightIndex ] ; 
    
    float3 f3SpotLightDir ; 
    f3SpotLightDir . xy = f4SpotParams . xy ; 
    f3SpotLightDir . z = sqrt ( 1.f - f3SpotLightDir . x * f3SpotLightDir . x - f3SpotLightDir . y * f3SpotLightDir . y ) ; 
    
    f3SpotLightDir . z = ( f4SpotParams . z > 0.f ) ? f3SpotLightDir . z : - f3SpotLightDir . z ; 
    
    float3 f3LightPosition = f4BoundingSphereAndRadius . xyz - f4BoundingSphereAndRadius . w * f3SpotLightDir ; 
    
    float3 f3ToLight = f3LightPosition - f3Position ; 
    float3 f3ToLightNorm = normalize ( f3ToLight ) ; 
    float fLightDistance = length ( f3ToLight ) ; 
    
    float fCosineOfCurrentConeAngle = dot ( - f3ToLightNorm , f3SpotLightDir ) ; 
    
    f3LightColorDiffuseFrontRes = float3 ( 0.f , 0.f , 0.f ) ; 
    f3LightColorSpecularFrontRes = float3 ( 0.f , 0.f , 0.f ) ; 
    f3LightColorDiffuseBackRes = float3 ( 0.f , 0.f , 0.f ) ; 
    f3LightColorSpecularBackRes = float3 ( 0.f , 0.f , 0.f ) ; 
    
    float fRad = f4SpotParams . w ; 
    float fCosineOfConeAngle = ( f4SpotParams . z > 0 ) ? f4SpotParams . z : - f4SpotParams . z ; 
    if ( fLightDistance < fRad && fCosineOfCurrentConeAngle > fCosineOfConeAngle ) 
    { 
        float fRadialAttenuation = ( fCosineOfCurrentConeAngle - fCosineOfConeAngle ) / ( 1.f - fCosineOfConeAngle ) ; 
        fRadialAttenuation = fRadialAttenuation * fRadialAttenuation ; 
        
        float fx = fLightDistance / fRad ; 
        
#line 150
        float fFallOff = fRad * ( saturate ( pow ( ( 1.f - pow ( fx , 4 ) ) , 2 ) ) ) / ( ( fLightDistance * fLightDistance ) + 1 ) ; 
        float3 f3LightColor = g_spotLightColorBuffer [ uLightIndex ] . rgb ; 
        
        f3LightColorDiffuseFrontRes = f3LightColor * saturate ( dot ( f3ToLightNorm , f3Norm ) ) * fFallOff * fRadialAttenuation ; 
        f3LightColorDiffuseFrontRes *= fH ; 
        f3LightColorDiffuseFrontRes *= 10 ; 
        float3 f3HalfAngle = normalize ( f3ViewDir + f3ToLightNorm ) ; 
        
        float fSpecMul = fLightingFuncGGX ( f3Norm , f3ViewDir , f3ToLight , fSpecularRoughness , fSpecularIOR ) ; 
        f3LightColorSpecularFrontRes = g_spotLightColorBuffer [ uLightIndex ] . rgb * fSpecMul * fFallOff * fRadialAttenuation ; 
        f3LightColorSpecularFrontRes *= 10 ; 
        
        f3LightColorDiffuseBackRes = f3LightColor * saturate ( dot ( f3ToLightNorm , - f3Norm ) ) * fFallOff * fRadialAttenuation ; 
        f3LightColorDiffuseBackRes *= fH ; 
        f3LightColorDiffuseBackRes * 10 ; 
        
        f3LightColorSpecularBackRes = g_spotLightColorBuffer [ uLightIndex ] . rgb * fSpecMul * fFallOff * fRadialAttenuation ; 
        f3LightColorSpecularBackRes *= 10 ; 
        
#line 170
        [ branch ] 
        if ( uSpecularWhite ) 
        f3LightColorSpecularFrontRes = 2 * ( f3LightColorSpecularFrontRes * f3LightColorDiffuseFrontRes ) ; 
        else if ( uSpecularAsImage ) 
        f3LightColorSpecularFrontRes = 2 * f4SpecMapCol . xyz * ( f3LightColorSpecularFrontRes * f3LightColorDiffuseFrontRes ) ; 
        else 
        f3LightColorSpecularFrontRes = 2 * f4SpecMapCol . xyz * ( f3LightColorSpecularFrontRes * f3LightColorDiffuseFrontRes ) ; 
        
        float fShadowRes = ApplySpotShadow ( uLightIndex , f3Position ) ; 
        f3LightColorDiffuseFrontRes *= fShadowRes ; 
        f3LightColorSpecularFrontRes *= fShadowRes ; 
        f3LightColorDiffuseBackRes *= fShadowRes ; 
        f3LightColorSpecularBackRes *= fShadowRes ; 
        
    } 
} 

#line 189
VS_OUTPUT_ALPHA_BLENDED_DEPTH RenderBlendedDepthVS ( VS_INPUT_ALPHA_BLENDED input ) 
{ 
    VS_OUTPUT_ALPHA_BLENDED_DEPTH output ; 
    
    float4 f4WorldPos = mul ( float4 ( input . f4Pos ) , g_mWorld ) ; 
    output . f4Pos = mul ( f4WorldPos , g_mViewProj ) ; 
    
    return output ; 
} 

#line 201
VS_OUTPUT_ALPHA_BLENDED RenderBlendedVS ( VS_INPUT_ALPHA_BLENDED input ) 
{ 
    VS_OUTPUT_ALPHA_BLENDED output ; 
    
    float4 f4WorldPos = mul ( input . f4Pos , g_mWorld ) ; 
    output . f4Pos = mul ( f4WorldPos , g_mViewProj ) ; 
    output . f3VertexPos = f4WorldPos . xyz ; 
    output . f3Normal = mul ( input . f3Normal , ( float3x3 ) g_mWorld ) ; 
    output . f2TexCoord = input . f2TexCoord ; 
    output . f3Tangent = input . f3Tangent ; 
    
    float4 f4z ; 
    f4z . xyz = 0.f ; 
    f4z . w = 1.f ; 
    
    output . f3CamPos = mul ( f4z , g_mViewInv ) . xyz ; 
    
    return output ; 
} 

#line 223
float4 RenderBlendedPS ( VS_OUTPUT_ALPHA_BLENDED input ) : SV_TARGET 
{ 
    float3 f3VertexPos = input . f3VertexPos ; 
    
    float3 f3AccumDiffuseFront = float3 ( 0.f , 0.f , 0.f ) ; 
    float3 f3AccumSpecularFront = float3 ( 0.f , 0.f , 0.f ) ; 
    float3 f3AccumDiffuseBack = float3 ( 0.f , 0.f , 0.f ) ; 
    float3 f3AccumSpecularBack = float3 ( 0.f , 0.f , 0.f ) ; 
    
    if ( uiyPos > 1 || uiyPics > 1 ) 
    { 
        float fxPic = uixPos ; 
        float fyPic = uiyPos ; 
        float fxPics = uixPics ; 
        float fyPics = uiyPics ; 
        input . f2TexCoord . x = fxPic / fxPics + input . f2TexCoord . x * ( 1.f / fxPics ) ; 
        input . f2TexCoord . y = fyPic / fyPics + input . f2TexCoord . y * ( 1.f / fyPics ) ; 
    } 
    
#line 244
    float3 f3Norm = tex2D [ 3 ] . Sample ( g_Sampler , input . f2TexCoord ) . xyz ; 
    f3Norm *= 2 ; 
    f3Norm -= float3 ( 1 , 1 , 1 ) ; 
    float3 f3N = normalize ( input . f3Normal ) ; 
    
#line 253
    float4 f4SpecMapCol = float4 ( 0.f , 0.f , 0.f , 0.f ) ; 
    if ( uSpecular ) 
    f4SpecMapCol = tex2D [ 0 ] . Sample ( g_Sampler , input . f2TexCoord ) ; 
    
    float3 f3C1 = cross ( f3N , float3 ( 0.f , 0.f , 1.f ) ) ; 
    float3 f3C2 = cross ( f3N , float3 ( 0.f , 1.f , 0.f ) ) ; 
    float3 f3T ; 
    [ branch ] 
    if ( length ( f3C1 ) > length ( f3C2 ) ) 
    { 
        f3T = f3C1 ; 
    } 
    else 
    { 
        f3T = f3C2 ; 
    } 
    float3 f3B = normalize ( - cross ( f3N , f3T ) ) ; 
    
#line 273
    if ( uBump ) 
    { 
        float3 f3BumpNormal = ( ( 2 * ( tex2D [ 3 ] . Sample ( g_Sampler , input . f2TexCoord ) ) ) - 1.f ) . xyz ; 
        f3BumpNormal *= fBumpStrength ; 
        input . f3Normal += f3BumpNormal . x * f3T + f3BumpNormal . y * f3B ; 
        input . f3Normal = normalize ( input . f3Normal ) ; 
    } 
    
#line 282
    float3x3 BTNMat = float3x3 ( f3B , f3T , f3N ) ; 
    f3Norm = normalize ( mul ( f3Norm , BTNMat ) ) ; 
    
    float3 f3ViewDir = normalize ( g_f3CameraPos - f3VertexPos ) ; 
    
#line 288
    { 
        uint uStartIndex , uLightCount ; 
        GetLightListInfo ( g_perTilePointLightIndexBuffer , g_uMaxNumLightsPerTile , g_uMaxNumElementsPerTile , input . f4Pos , 
        uStartIndex , uLightCount ) ; 
        
        [ loop ] 
        for ( uint i = uStartIndex ; i < uStartIndex + uLightCount ; i ++ ) 
        { 
            uint uLightIndex = g_perTilePointLightIndexBuffer [ i ] ; 
            
            float3 f3LightColorDiffuseFrontRes = float3 ( 0.f , 0.f , 0.f ) ; 
            float3 f3LightColorSpecularFrontRes = float3 ( 0.f , 0.f , 0.f ) ; 
            float3 f3LightColorDiffuseBackRes = float3 ( 0.f , 0.f , 0.f ) ; 
            float3 f3LightColorSpecularBackRes = float3 ( 0.f , 0.f , 0.f ) ; 
            
            ApplyPointLightingTwoSided ( uLightIndex , f3VertexPos , f3Norm , f3ViewDir , f4SpecMapCol , input . f2TexCoord , 
            f3LightColorDiffuseFrontRes , f3LightColorSpecularFrontRes , 
            f3LightColorDiffuseBackRes , f3LightColorSpecularBackRes ) ; 
            
            f3LightColorDiffuseFrontRes += ( 8.f * ( 1.f - frTransparency ) * f3LightColorDiffuseFrontRes ) ; 
            f3LightColorDiffuseBackRes += ( 8.f * ( 1.f - frTransparency ) * f3LightColorDiffuseBackRes ) ; 
            f3LightColorSpecularFrontRes += ( 8.f * ( 1.f - frTransparency ) * f3LightColorSpecularFrontRes ) ; 
            f3LightColorSpecularBackRes += ( 8.f * ( 1.f - frTransparency ) * f3LightColorSpecularBackRes ) ; 
            
            if ( uTexSSS ) 
            { 
                float4 f4CenterAndRadius = g_pointLightCenterAndRadiusBuffer [ uLightIndex ] ; 
                float3 f3ToLight = f4CenterAndRadius . xyz - f3VertexPos ; 
                
                float3 f3LightCol = g_pointLightColorBuffer [ uLightIndex ] . rgb ; 
                
                const float4 f4TexColor = tex2D [ 0 ] . Sample ( g_Sampler , input . f2TexCoord ) ; 
                const float fThickValue = length ( tex2D [ 6 ] . Sample ( g_Sampler , input . f2TexCoord ) . rgb ) ; 
                
                SubsurfaceScattering ( f4CenterAndRadius , f3ToLight , f3LightCol , f4TexColor , fThickValue , f4SSSBRDFParams , 
                f4ColorSSS , float4 ( input . f3VertexPos , 1.f ) , input . f3CamPos , input . f3Normal , true , 
                f3LightColorSpecularFrontRes , f3LightColorDiffuseFrontRes ) ; 
                
                SubsurfaceScattering ( f4CenterAndRadius , f3ToLight , f3LightCol , f4TexColor , fThickValue , f4SSSBRDFParams , 
                f4ColorSSS , float4 ( input . f3VertexPos , 1.f ) , input . f3CamPos , input . f3Normal , true , 
                f3LightColorSpecularBackRes , f3LightColorDiffuseBackRes ) ; 
                
            } 
            
            const float3 f3EyeVector = normalize ( input . f3CamPos . xyz - input . f3VertexPos ) ; 
            const float3 f3ViewDir = - f3EyeVector ; 
            
            f3AccumDiffuseFront += f3LightColorDiffuseFrontRes ; 
            f3AccumSpecularFront += f3LightColorSpecularFrontRes ; 
            f3AccumDiffuseBack += f3LightColorDiffuseBackRes ; 
            f3AccumSpecularBack += f3LightColorSpecularBackRes ; 
        } 
    } 
    
#line 343
    { 
        uint uStartIndex , uLightCount ; 
        GetLightListInfo ( g_perTileSpotLightIndexBuffer , g_uMaxNumLightsPerTile , g_uMaxNumElementsPerTile , input . f4Pos , 
        uStartIndex , uLightCount ) ; 
        
        [ loop ] 
        for ( uint i = uStartIndex ; i < uStartIndex + uLightCount ; i ++ ) 
        { 
            uint uLightIndex = g_perTileSpotLightIndexBuffer [ i ] ; 
            
            float3 f3LightColorDiffuseFrontRes = float3 ( 0.f , 0.f , 0.f ) ; 
            float3 f3LightColorSpecularFrontRes = float3 ( 0.f , 0.f , 0.f ) ; 
            float3 f3LightColorDiffuseBackRes = float3 ( 0.f , 0.f , 0.f ) ; 
            float3 f3LightColorSpecularBackRes = float3 ( 0.f , 0.f , 0.f ) ; 
            
            ApplySpotLightingTwoSided ( uLightIndex , f3VertexPos , f3Norm , f3ViewDir , f4SpecMapCol , 
            f3LightColorDiffuseFrontRes , f3LightColorSpecularFrontRes , 
            f3LightColorDiffuseBackRes , f3LightColorSpecularBackRes ) ; 
            
            f3LightColorDiffuseFrontRes += ( 8.f * ( 1.f - frTransparency ) * f3LightColorDiffuseFrontRes ) ; 
            f3LightColorDiffuseBackRes += ( 8.f * ( 1.f - frTransparency ) * f3LightColorDiffuseBackRes ) ; 
            f3LightColorSpecularFrontRes += ( 8.f * ( 1.f - frTransparency ) * f3LightColorSpecularFrontRes ) ; 
            f3LightColorSpecularBackRes += ( 8.f * ( 1.f - frTransparency ) * f3LightColorSpecularBackRes ) ; 
            
            if ( uTexSSS ) 
            { 
                float4 f4CenterAndRadius = g_spotLightCenterAndRadiusBuffer [ uLightIndex ] ; 
                float3 f3ToLight = f4CenterAndRadius . xyz - f3VertexPos ; 
                
                float3 f3LightCol = g_spotLightColorBuffer [ uLightIndex ] . rgb ; 
                
                const float4 f4TexColor = tex2D [ 0 ] . Sample ( g_Sampler , input . f2TexCoord ) ; 
                const float fThickValue = length ( tex2D [ 6 ] . Sample ( g_Sampler , input . f2TexCoord ) . rgb ) ; 
                
                SubsurfaceScattering ( f4CenterAndRadius , f3ToLight , f3LightCol , f4TexColor , fThickValue , f4SSSBRDFParams , 
                f4ColorSSS , float4 ( input . f3VertexPos , 1.f ) , input . f3CamPos , input . f3Normal , true , 
                f3LightColorSpecularFrontRes , f3LightColorDiffuseFrontRes ) ; 
                
                SubsurfaceScattering ( f4CenterAndRadius , f3ToLight , f3LightCol , f4TexColor , fThickValue , f4SSSBRDFParams , 
                f4ColorSSS , float4 ( input . f3VertexPos , 1.f ) , input . f3CamPos , input . f3Normal , true , 
                f3LightColorSpecularBackRes , f3LightColorDiffuseBackRes ) ; 
                
            } 
            
#line 388
            f3AccumDiffuseFront += f3LightColorDiffuseFrontRes ; 
            f3AccumSpecularFront += f3LightColorSpecularFrontRes ; 
            f3AccumDiffuseBack += f3LightColorDiffuseBackRes ; 
            f3AccumSpecularBack += f3LightColorSpecularBackRes ; 
        } 
    } 
    
    f3AccumDiffuseFront *= 2.f ; 
    f3AccumSpecularFront *= 8.f ; 
    f3AccumDiffuseBack *= 2.f ; 
    f3AccumSpecularBack *= 8.f ; 
    
#line 401
    float fAmbientBlendFront = 0.5f * f3Norm * 0.5f ; 
    float3 f3AmbientFront = g_f4AmbientColorUp . rgb * fAmbientBlendFront + g_f4AmbientColorDown . rgb * ( 1 - fAmbientBlendFront ) ; 
    
    float fAmbientBlendBack = 0.5f * - f3Norm * 0.5f ; 
    float3 f3AmbientBack = g_f4AmbientColorUp . rgb * fAmbientBlendBack + g_f4AmbientColorDown . rgb * ( 1 - fAmbientBlendBack ) ; 
    
#line 408
    float3 f3Color = tex2D [ 0 ] . Sample ( g_Sampler , input . f2TexCoord ) . xyz * 0.25f ; 
    float3 f3DiffuseAndAmbientFront = ( f3AccumDiffuseFront * f3AmbientFront ) + f3Color ; 
    float3 f3DiffuseAndAmbientBack = ( f3AccumDiffuseBack * f3AmbientBack ) + f3Color ; 
    float fBackFaceWeight = 0.5f ; 
    float3 f3AccumLight = f3DiffuseAndAmbientFront + f3AccumSpecularFront + ( fBackFaceWeight * ( f3DiffuseAndAmbientBack + f3AccumSpecularBack ) ) ; 
    
    float4 f4DiffTex = tex2D [ 0 ] . Sample ( g_Sampler , input . f2TexCoord ) ; 
    
    if ( uChromaKeying ) 
    { 
        uint iWidth ; 
        uint iHeight ; 
        uint iLevels ; 
        tex2D [ 0 ] . GetDimensions ( 0 , iWidth , iHeight , iLevels ) ; 
        
#line 424
        float2 f2TexCoord2 = float2 ( input . f2TexCoord . x * iWidth , input . f2TexCoord . y * iHeight ) ; 
        int2 i2TexCoord = int2 ( input . f2TexCoord . x , input . f2TexCoord . y ) ; 
        
#line 428
        int3 i3Pos = int3 ( 0 , 0 , 0 ) ; 
        float4 f4ChromaKey = tex2D [ 0 ] . Load ( i3Pos ) ; 
        i3Pos = int3 ( i2TexCoord . x , i2TexCoord . y , 0 ) ; 
        float4 f4Texel = tex2D [ 0 ] . Load ( i3Pos ) ; 
        
#line 434
        if ( ( f4Texel . r == f4ChromaKey . r ) && ( f4Texel . g == f4ChromaKey . g ) && ( f4Texel . b == f4ChromaKey . b ) ) 
        f4DiffTex . a = 0 ; 
        
#line 438
        float2 f2TexPos1 = float2 ( f2TexCoord2 . x - 0.5 , f2TexCoord2 . y - 0.5 ) ; 
        float2 f2TexPos2 = float2 ( f2TexCoord2 . x + 0.5 , f2TexCoord2 . y - 0.5 ) ; 
        float2 f2TexPos3 = float2 ( f2TexCoord2 . x - 0.5 , f2TexCoord2 . y + 0.5 ) ; 
        float2 f2TexPos4 = float2 ( f2TexCoord2 . x + 0.5 , f2TexCoord2 . y + 0.5 ) ; 
        float4 f4Col1 = tex2D [ 0 ] . Load ( int3 ( f2TexPos1 . x , f2TexPos1 . y , 0 ) ) ; 
        float4 f4Col2 = tex2D [ 0 ] . Load ( int3 ( f2TexPos2 . x , f2TexPos2 . y , 0 ) ) ; 
        float4 f4Col3 = tex2D [ 0 ] . Load ( int3 ( f2TexPos3 . x , f2TexPos3 . y , 0 ) ) ; 
        float4 f4Col4 = tex2D [ 0 ] . Load ( int3 ( f2TexPos4 . x , f2TexPos4 . y , 0 ) ) ; 
        if ( ( f4Col1 . r == f4ChromaKey . r ) && ( f4Col1 . g == f4ChromaKey . g ) && ( f4Col1 . b == f4ChromaKey . b ) ) f4Col1 = 0 ; 
        if ( ( f4Col2 . r == f4ChromaKey . r ) && ( f4Col2 . g == f4ChromaKey . g ) && ( f4Col2 . b == f4ChromaKey . b ) ) f4Col2 = 0 ; 
        if ( ( f4Col3 . r == f4ChromaKey . r ) && ( f4Col3 . g == f4ChromaKey . g ) && ( f4Col3 . b == f4ChromaKey . b ) ) f4Col3 = 0 ; 
        if ( ( f4Col4 . r == f4ChromaKey . r ) && ( f4Col4 . g == f4ChromaKey . g ) && ( f4Col4 . b == f4ChromaKey . b ) ) f4Col4 = 0 ; 
        f2TexPos1 = float2 ( frac ( f2TexPos1 . x ) , frac ( f2TexPos1 . y ) ) ; 
        
#line 453
        float fAlpha = ( f4Col2 . a - f4Col1 . a ) * f2TexPos1 . x + f4Col1 . a ; 
        fAlpha = ( ( ( f4Col4 . a - f4Col3 . a ) * f2TexPos1 . x + f4Col3 . a ) - fAlpha ) * f2TexPos1 . y + fAlpha ; 
        
#line 457
        if ( fAlpha < 0.73 ) 
        f4DiffTex . a = fAlpha - 0.40 ; 
        
        f4Col1 = float4 ( 
        ( f4Col2 . r - f4Col1 . r ) * f2TexPos1 . x + f4Col1 . r , 
        ( f4Col2 . g - f4Col1 . g ) * f2TexPos1 . x + f4Col1 . g , 
        ( f4Col2 . b - f4Col1 . b ) * f2TexPos1 . x + f4Col1 . b , 
        0 ) ; 
        f4Col3 = float4 ( 
        ( f4Col4 . r - f4Col3 . r ) * f2TexPos1 . x + f4Col3 . r , 
        ( f4Col4 . g - f4Col3 . g ) * f2TexPos1 . x + f4Col3 . g , 
        ( f4Col4 . b - f4Col3 . b ) * f2TexPos1 . x + f4Col3 . b , 
        0 ) ; 
        f4DiffTex = float4 ( 
        ( f4Col3 . r - f4Col1 . r ) * f2TexPos1 . y + f4Col1 . r , 
        ( f4Col3 . g - f4Col1 . g ) * f2TexPos1 . y + f4Col1 . g , 
        ( f4Col3 . b - f4Col1 . b ) * f2TexPos1 . y + f4Col1 . b , 
        fAlpha ) ; 
        
    } 
    
    float4 f4ColorOut = 2 * float4 ( f3AccumLight , 1.f ) ; 
    
    if ( uEnvironment ) 
    { 
        float3 f3EyeVector = normalize ( input . f3CamPos - input . f3VertexPos ) ; 
        float3 f3Reflection = reflect ( f3EyeVector , input . f3Normal ) ; 
        float3 f3Refraction = refract ( f3EyeVector , input . f3Normal , .99f ) ; 
        
        float3 f3RefrColor = tex2D [ 4 ] . Sample ( g_Sampler , f3Refraction . xy ) . rgb ; 
        float3 f3ReflColor = tex2D [ 4 ] . Sample ( g_Sampler , f3Reflection . xy ) . rgb ; 
        if ( uReflectionMap ) 
        { 
            float fReflectionFactor = tex2D [ 4 ] . Sample ( g_Sampler , input . f2TexCoord ) . a ; 
            f4ColorOut . rgb *= fReflectionFactor * ( lerp ( f3RefrColor , f3ReflColor , .5f ) / f4ColorSSS . a ) * ( length ( f4ColorOut . rgb ) * length ( f4ColorOut . rgb ) ) ; 
        } 
        else 
        { 
            f4ColorOut . rgb += ( lerp ( f3RefrColor , f3ReflColor , .5f ) / f4ColorSSS . a ) * ( length ( f4ColorOut . rgb ) * length ( f4ColorOut . rgb ) ) ; 
            
        } 
    } 
    float fTrans = min ( frTransparency , f4DiffTex . a ) ; 
    
    f4ColorOut . a = fTrans ; 
    
    return f4ColorOut ; 
}  